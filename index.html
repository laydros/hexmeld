<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hexmeld - Hexagonal Puzzle Game</title>
    <link rel="icon" href="assets/hexmeld-icon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="assets/hexmeld-icon-180.png">
    <link rel="mask-icon" href="assets/hexmeld-icon.svg" color="#5b7fff">
    <meta name="theme-color" content="#0b1020">
    <link rel="manifest" href="assets/manifest.webmanifest">
    <style>
        :root{color-scheme:dark light;--bg-dark:#1a1f35;--panel-dark:#242b45;--text-dark:#e8ebf0;--muted-dark:#93a0b4;--bg-light:#f6f7fb;--panel-light:#fff;--text-light:#0f1422;--muted-light:#5b667a;--primary:#5b7fff;--danger:#ff6b6b;--gap:12px}
        *,*::before,*::after{box-sizing:border-box}
        body{margin:0;min-height:100vh;display:flex;flex-direction:column;gap:var(--gap);padding:var(--gap);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial;--bg:var(--bg-dark);--panel:var(--panel-dark);--text:var(--text-dark);--muted:var(--muted-dark);background:var(--bg);color:var(--text)}
        body.theme-dark{color-scheme:dark;--bg:var(--bg-dark);--panel:var(--panel-dark);--text:var(--text-dark);--muted:var(--muted-dark)}
        body.theme-light{color-scheme:light;--bg:var(--bg-light);--panel:var(--panel-light);--text:var(--text-light);--muted:var(--muted-light)}
        @media (prefers-color-scheme: light){body:not(.theme-dark){color-scheme:light;--bg:var(--bg-light);--panel:var(--panel-light);--text:var(--text-light);--muted:var(--muted-light)}}
        .panel{max-width:660px;width:100%;margin:0 auto;padding:12px;background:var(--panel);border-radius:10px;box-shadow:0 8px 24px rgba(0,0,0,.2)}

        .header{display:block}
        h1{font-size:1.4rem;margin:0}
        .meta{color:var(--muted)}
        .button{display:inline-block;padding:.5rem .75rem;border-radius:8px;border:0;font-weight:600;color:#fff;background:var(--primary);cursor:pointer;transition:transform .12s ease,filter .12s ease}
        .button:hover{transform:translateY(-1px);filter:brightness(1.08)}
        .button:active{transform:translateY(0);filter:brightness(.95)}
        .button.ghost{background:transparent;outline:1px solid #0004;color:var(--text)}
        .button.danger{background:var(--danger)}
        .button:disabled{opacity:.5;cursor:not-allowed}
        #canvas.shake{animation:shake .32s ease-in-out}
        @keyframes shake{
            0%,100%{transform:translateX(0)}
            20%{transform:translateX(-4px)}
            40%{transform:translateX(4px)}
            60%{transform:translateX(-2px)}
            80%{transform:translateX(2px)}
        }
        main{flex:1;display:flex;flex-direction:column;align-items:center;gap:var(--gap);width:100%}
        #gameContainer{display:flex;flex-direction:column;gap:var(--gap);align-items:center}
        #canvas{width:100%;height:auto;max-width:520px;border-radius:12px;background:#0001;border:1px solid #0004;box-shadow:0 12px 24px rgba(0,0,0,.25)}
        #preview{display:flex;gap:8px;align-items:center;font-weight:600}
        .previewBall{width:22px;height:22px;border-radius:50%;border:2px solid rgba(0,0,0,.35)}
        footer{margin-top:auto;text-align:center;font-size:.85rem;color:var(--muted)}
        footer a{color:inherit;text-decoration:none}
        footer a:hover{text-decoration:underline}
        #versionDisplay{margin-top:6px;font-size:.75rem}
        #gameOver{position:fixed;inset:0;display:none;align-items:center;justify-content:center;padding:20px;background:rgba(11,16,32,.85);backdrop-filter:blur(4px);z-index:20}
        #gameOver .panel{max-width:360px;text-align:center}
        #gameOver h2{margin:0 0 12px;font-size:1.5rem}
        #gameOver p{margin:6px 0;color:var(--muted)}
        #resetButton{margin-top:16px}
        @media (max-width:768px){
            body{padding:var(--gap) 0 calc(var(--gap)*2);}
            .panel{border-radius:0;}
            #gameContainer{padding:10px 8px 16px;}
            #canvas{max-width:100%;border-radius:8px;}
        }
    </style>
</head>
<body>
    <header class="panel header" role="banner">
      <div style="display:flex;justify-content:space-between;align-items:center;width:100%;margin-bottom:8px">
        <h1 style="display:flex;gap:8px;align-items:center;margin:0">
          <img src="assets/hexmeld-icon.svg" alt="" width="24" height="24"> Hexmeld
        </h1>
        <div style="display:flex;gap:8px;align-items:center">
          <button id="themeToggle" class="button ghost" aria-pressed="false" title="Toggle theme">Theme</button>
          <button id="playAgain" class="button" title="Restart">Play Again</button>
        </div>
      </div>
      <div class="meta">Score <strong id="score">0</strong> · High <strong id="high">0</strong> · Turn <strong id="turn">0</strong> · Filled <strong id="filled">0</strong></div>
    </header>

    <main>
      <section class="panel" id="gameContainer">
        <div id="preview" class="meta" aria-live="polite">
          <span>Next:</span>
        </div>
        <canvas id="canvas"></canvas>
      </section>
    </main>

    <div id="gameOver">
      <div class="panel">
        <h2>Game Over</h2>
        <p>Your Score: <span id="finalScore">0</span> · Turn <span id="finalTurns">0</span></p>
        <p>High Score: <span id="highScore">0</span></p>
        <button id="resetButton" class="button">Play Again</button>
      </div>
    </div>

    <footer>
      <div>
        <a href="instructions.html">How to Play</a> ·
        <a href="https://github.com/laydros/hexmeld" target="_blank" rel="noopener">View on GitHub</a>
      </div>
      <div id="versionDisplay"></div>
    </footer>

    <script type="module">
        // Theme toggle: cycles system → dark → light (persists)
        (()=>{const k='hexmeld-theme',b=document.body,t=document.getElementById('themeToggle');
        let currentTheme=localStorage.getItem(k);
        const apply=v=>{currentTheme=v;b.classList.remove('theme-dark','theme-light');if(v) b.classList.add('theme-'+v);if(t) t.setAttribute('aria-pressed',v?'true':'false');};
        apply(currentTheme);
        t&&t.addEventListener('click',()=>{const v=currentTheme==='dark'?'light':currentTheme==='light'?null:'dark';apply(v);v?localStorage.setItem(k,v):localStorage.removeItem(k);});})();

        // HUD refs
        const elScore=document.getElementById('score');
        const elHigh=document.getElementById('high');
        const elTurn=document.getElementById('turn');
        const elFilled=document.getElementById('filled');
        const btnAgain=document.getElementById('playAgain');

        export function hudSet(score, high, turn, filled){
          if(elScore) elScore.textContent=score|0;
          if(elHigh) elHigh.textContent=high|0;
          if(elTurn) elTurn.textContent=turn|0;
          if(elFilled!==undefined && elFilled) elFilled.textContent=filled|0;
        }

        btnAgain&&btnAgain.addEventListener('click',()=>{ if(typeof restartGame==='function') restartGame(); });

        export function flashInvalid(el){
          if(!el) return;
          el.classList.remove('shake');
          void el.offsetWidth;
          el.classList.add('shake');
          setTimeout(()=>el.classList.remove('shake'), 360);
        }

        // Version check
        const GAME_VERSION = '1.1.2';
        console.log('Hexmeld version:', GAME_VERSION);
        document.getElementById('versionDisplay').textContent = `v${GAME_VERSION}`;

        // Constants
        const BOARD_RADIUS = 6;
        const COLORS = [
            '#0000FF', // Blue
            '#FFFF00', // Yellow
            '#FF0000', // Red
            '#00FF00', // Green
            '#FFA500', // Orange
            '#800080', // Purple
            '#FFFFFF', // White
            '#00FFFF'  // Turquoise
        ];

        function adjustColor(hex, amount) {
            if (!hex) return '#FFFFFF';
            let color = hex.replace('#', '');
            if (color.length === 3) {
                color = color.split('').map(c => c + c).join('');
            }

            const num = parseInt(color, 16);
            let r = (num >> 16) + amount;
            let g = ((num >> 8) & 0xff) + amount;
            let b = (num & 0xff) + amount;

            const clamp = (value) => Math.max(0, Math.min(255, value));
            r = clamp(r);
            g = clamp(g);
            b = clamp(b);

            const toHex = (value) => value.toString(16).padStart(2, '0');
            return `#${toHex(r)}${toHex(g)}${toHex(b)}`.toUpperCase();
        }

        // ====== GAME CONFIG (EDIT HERE FOR TESTING) ======
        const COLOR_CONFIG = {
            startingColors: 6,  // Start with first 6 colors (0-5)
            expansions: [
                { afterTurn: 20, addColors: 2 }  // After turn 20, add 2 more colors (indices 6-7)
                // Add more expansions like: { afterTurn: 50, addColors: 2 }
            ]
        };

        const SPAWN_CONFIG = {
            startingSpawnCount: 3,  // Start spawning 3 balls per turn
            increases: [
                { afterTurn: 40, spawnCount: 4 }, // After turn 40, spawn 4 balls per turn
                { afterTurn: 80, spawnCount: 5 }  // After turn 80, spawn 5 balls per turn
            ],
            boardThresholds: [
                { emptyCells: 10, spawnCount: 3 }, // When ≤10 empty cells, cap spawns at 3
                { emptyCells: 20, spawnCount: 4 }  // When ≤20 empty cells, cap spawns at 4
            ]
        };

        const SPAWN_INCREASES_SORTED = [...(SPAWN_CONFIG.increases || [])].sort((a, b) => a.afterTurn - b.afterTurn);
        const SPAWN_THRESHOLDS_SORTED = [...(SPAWN_CONFIG.boardThresholds || [])].sort((a, b) => a.emptyCells - b.emptyCells);
        // ==================================================

        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Game state
        let grid = new Map();
        let selectedCell = null;
        let selectedBallAnimation = null;
        let score = 0;
        let turnCount = 0;
        let availableColorCount = COLOR_CONFIG.startingColors;
        let preview = [];
        let gameOver = false;
        let highScore = 0;
        let inputLocked = false; // Prevent input during animations

        // Animation state
        const animations = [];
        let animationFrameId = null;

        // Dynamic sizing
        let HEX_SIZE = 25;
        let hexWidth = HEX_SIZE * 2;
        let hexHeight = Math.sqrt(3) * HEX_SIZE;
        let isMobile = false;
        let hitRadius = HEX_SIZE * 0.5;

        // Calculate optimal canvas size and hex size
        function calculateCanvasSize() {
            // Detect mobile
            isMobile = window.innerWidth < 768;

            // Minimal canvas padding
            const canvasPadding = isMobile ? 20 : 40;

            // Available space for the entire canvas
            const availableWidth = window.innerWidth - canvasPadding;
            const headerAllowance = isMobile ? 220 : 260;
            const availableHeight = window.innerHeight - headerAllowance;

            // Board dimensions: how much space the hex board actually needs
            // Horizontal: furthest hex at q=±BOARD_RADIUS is at ±(1.5 * BOARD_RADIUS * HEX_SIZE)
            // Plus one hex radius on each side = total of (3 * BOARD_RADIUS + 2) * HEX_SIZE
            const boardHexWidth = 3 * BOARD_RADIUS + 2;

            // Vertical: approximately (sqrt(3) * (BOARD_RADIUS * 2 + 1)) * HEX_SIZE
            const boardHexHeight = Math.sqrt(3) * (BOARD_RADIUS * 2 + 1);

            // Calculate max hex size that fits with tight padding around board
            const boardPadding = isMobile ? 10 : 20; // Padding around the board within canvas
            const maxHexWidth = (availableWidth - boardPadding * 2) / boardHexWidth;
            const maxHexHeight = (availableHeight - boardPadding * 2) / boardHexHeight;

            const sizeCap = isMobile ? 25 : 22;
            HEX_SIZE = Math.min(maxHexWidth, maxHexHeight, sizeCap);
            // Ensure minimum size of 20px for mobile touch targets
            HEX_SIZE = Math.max(HEX_SIZE, isMobile ? 20 : 10);

            hexWidth = HEX_SIZE * 2;
            hexHeight = Math.sqrt(3) * HEX_SIZE;

            // Update hit radius based on device type
            hitRadius = isMobile ? HEX_SIZE * 0.6 : HEX_SIZE * 0.5;

            // Calculate tight canvas dimensions: just enough for board + padding
            const canvasWidth = boardHexWidth * HEX_SIZE + boardPadding * 2;
            const canvasHeight = boardHexHeight * HEX_SIZE + boardPadding * 2;

            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
        }

        // ====== ANIMATION FRAMEWORK ======

        // Easing functions
        function easeOutQuad(t) {
            return 1 - Math.pow(1 - t, 2);
        }

        function easeInQuad(t) {
            return t * t;
        }

        // Animation loop
        function animationLoop() {
            if (animations.length === 0) {
                animationFrameId = null;
                return;
            }

            const now = performance.now();

            // Update all animations
            for (let i = animations.length - 1; i >= 0; i--) {
                const anim = animations[i];
                const elapsed = now - anim.startTime;
                const progress = Math.min(1, elapsed / anim.duration);

                anim.update(progress);

                if (progress >= 1) {
                    if (anim.onComplete) {
                        anim.onComplete();
                    }
                    animations.splice(i, 1);
                }
            }

            render();

            if (animations.length > 0) {
                animationFrameId = requestAnimationFrame(animationLoop);
            } else {
                animationFrameId = null;
            }
        }

        // Add an animation
        function addAnimation(update, onComplete, duration) {
            animations.push({
                startTime: performance.now(),
                duration,
                update,
                onComplete
            });

            if (!animationFrameId) {
                animationFrameId = requestAnimationFrame(animationLoop);
            }
        }

        function stopSelectedBallHop() {
            if (selectedBallAnimation) {
                selectedBallAnimation = null;
            }
        }

        function startSelectedBallHop(cellKey) {
            if (!cellKey) return;
            const token = Symbol('selectedHop');
            selectedBallAnimation = { cellKey, offsetY: 0, scale: 1, token };
            queueSelectedBallHop(cellKey, token);
        }

        function queueSelectedBallHop(cellKey, token) {
            const hopHeight = HEX_SIZE * 0.22;
            const hopDuration = 420;

            addAnimation(
                (progress) => {
                    if (!selectedBallAnimation || selectedBallAnimation.cellKey !== cellKey || selectedBallAnimation.token !== token) {
                        return;
                    }
                    const hopProgress = Math.sin(progress * Math.PI);
                    selectedBallAnimation.offsetY = -hopHeight * hopProgress;
                    selectedBallAnimation.scale = 1 + 0.08 * hopProgress;
                },
                () => {
                    if (!selectedBallAnimation || selectedBallAnimation.cellKey !== cellKey || selectedBallAnimation.token !== token) {
                        return;
                    }
                    selectedBallAnimation.offsetY = 0;
                    selectedBallAnimation.scale = 1;
                    queueSelectedBallHop(cellKey, token);
                },
                hopDuration
            );
        }

        // Wait for all animations to complete
        function waitForAnimations(callback) {
            if (animations.length === 0) {
                callback();
            } else {
                const checkInterval = setInterval(() => {
                    if (animations.length === 0) {
                        clearInterval(checkInterval);
                        callback();
                    }
                }, 10);
            }
        }

        // ====== END ANIMATION FRAMEWORK ======

        // Animation overlays (drawn on top of normal rendering)
        let animatedBalls = []; // { q, r, color, scale, opacity }
        let blockedCell = null; // { q, r, flashProgress }
        let blockedSourceCell = null; // { q, r, flashProgress }
        let touchedHex = null; // For touch feedback

        // ====== END ANIMATION FRAMEWORK ======

        // Load high score from localStorage
        function loadHighScore() {
            const saved = localStorage.getItem('hexmeldHighScore');
            highScore = saved ? parseInt(saved, 10) : 0;
        }

        // Save high score to localStorage
        function saveHighScore() {
            localStorage.setItem('hexmeldHighScore', highScore.toString());
        }

        // Initialize game
        function init() {
            calculateCanvasSize();
            grid.clear();
            stopSelectedBallHop();
            selectedCell = null;
            score = 0;
            turnCount = 0;
            availableColorCount = COLOR_CONFIG.startingColors;
            gameOver = false;
            document.getElementById('gameOver').style.display = 'none';

            // Load high score
            loadHighScore();
            hudSet(score, highScore, turnCount, grid.size);

            // Generate initial preview
            preview = generatePreview();
            updatePreviewDisplay();

            // Place 5 starting balls
            const startBalls = 5;
            const emptyCells = getAllEmptyCells();
            for (let i = 0; i < startBalls; i++) {
                if (emptyCells.length > 0) {
                    const idx = Math.floor(Math.random() * emptyCells.length);
                    const cell = emptyCells.splice(idx, 1)[0];
                    const color = Math.floor(Math.random() * availableColorCount);
                    grid.set(cell, { color });
                }
            }

            updateScore();
            updateTurnDisplay();
            render();
        }

        export function restartGame(){
            init();
        }

        // Update available colors based on turn count
        function updateAvailableColors() {
            let newColorCount = COLOR_CONFIG.startingColors;
            for (const expansion of COLOR_CONFIG.expansions) {
                if (turnCount >= expansion.afterTurn) {
                    newColorCount += expansion.addColors;
                }
            }
            availableColorCount = Math.min(newColorCount, COLORS.length);
        }

        // Get spawn count based on turn and remaining empty cells
        function getSpawnCountForState(turn, emptyCellsCount) {
            let spawnCount = SPAWN_CONFIG.startingSpawnCount;

            for (const increase of SPAWN_INCREASES_SORTED) {
                if (turn >= increase.afterTurn) {
                    spawnCount = increase.spawnCount;
                } else {
                    break;
                }
            }

            for (const threshold of SPAWN_THRESHOLDS_SORTED) {
                if (emptyCellsCount <= threshold.emptyCells) {
                    spawnCount = Math.min(spawnCount, threshold.spawnCount);
                }
            }

            return spawnCount;
        }

        // Generate preview of random balls (looks ahead to next turn's spawn count)
        function generatePreview() {
            const emptyCellsCount = getAllEmptyCells().length;
            const nextTurnSpawnCount = getSpawnCountForState(turnCount + 1, emptyCellsCount);
            const spawnTotal = Math.min(nextTurnSpawnCount, emptyCellsCount);
            const previewArray = [];
            for (let i = 0; i < spawnTotal; i++) {
                previewArray.push(Math.floor(Math.random() * availableColorCount));
            }
            return previewArray;
        }

        // Update preview display
        function updatePreviewDisplay() {
            const previewContainer = document.getElementById('preview');
            // Clear existing preview balls (except the "Next:" label)
            const existingBalls = previewContainer.querySelectorAll('.previewBall');
            existingBalls.forEach(ball => ball.remove());

            // Add new preview balls
            for (let i = 0; i < preview.length; i++) {
                const ball = document.createElement('div');
                ball.className = 'previewBall';
                ball.style.backgroundColor = COLORS[preview[i]];
                previewContainer.appendChild(ball);
            }
        }

        // Update score display
        function updateScore() {
            hudSet(score, highScore, turnCount, grid.size);
        }

        // Update turn display
        function updateTurnDisplay() {
            hudSet(score, highScore, turnCount, grid.size);
        }

        // Get all valid hex cells for the board
        function getAllCells() {
            const cells = [];
            for (let q = -BOARD_RADIUS; q <= BOARD_RADIUS; q++) {
                for (let r = -BOARD_RADIUS; r <= BOARD_RADIUS; r++) {
                    const s = -q - r;
                    if (Math.abs(s) <= BOARD_RADIUS) {
                        cells.push(`${q},${r}`);
                    }
                }
            }
            return cells;
        }

        // Get all empty cells
        function getAllEmptyCells() {
            return getAllCells().filter(cell => !grid.has(cell));
        }

        // Convert offset coordinates to cube coordinates
        function offsetToCube(col, row) {
            const q = col;
            const r = row - (col - (col & 1)) / 2;
            return { q, r, s: -q - r };
        }

        // Convert cube coordinates to offset coordinates
        function cubeToOffset(q, r) {
            const col = q;
            const row = r + (q - (q & 1)) / 2;
            return { col, row };
        }

        // Get hex center position in pixels
        function hexToPixel(q, r) {
            const x = HEX_SIZE * (3/2 * q);
            const y = HEX_SIZE * (Math.sqrt(3)/2 * q + Math.sqrt(3) * r);
            return {
                x: x + canvas.width / 2,
                y: y + canvas.height / 2
            };
        }

        // Convert pixel to hex coordinates
        function pixelToHex(x, y) {
            x -= canvas.width / 2;
            y -= canvas.height / 2;

            const q = (2/3 * x) / HEX_SIZE;
            const r = (-1/3 * x + Math.sqrt(3)/3 * y) / HEX_SIZE;
            return hexRound(q, r);
        }

        // Round fractional hex coordinates to nearest hex
        function hexRound(q, r) {
            let s = -q - r;

            let rq = Math.round(q);
            let rr = Math.round(r);
            let rs = Math.round(s);

            const q_diff = Math.abs(rq - q);
            const r_diff = Math.abs(rr - r);
            const s_diff = Math.abs(rs - s);

            if (q_diff > r_diff && q_diff > s_diff) {
                rq = -rr - rs;
            } else if (r_diff > s_diff) {
                rr = -rq - rs;
            }

            return { q: rq, r: rr };
        }

        // Check if hex is valid (within board)
        function isValidHex(q, r) {
            const s = -q - r;
            return Math.abs(q) <= BOARD_RADIUS &&
                   Math.abs(r) <= BOARD_RADIUS &&
                   Math.abs(s) <= BOARD_RADIUS;
        }

        // Get neighbors of a hex
        function getNeighbors(q, r) {
            const directions = [
                {q: 1, r: 0}, {q: 1, r: -1}, {q: 0, r: -1},
                {q: -1, r: 0}, {q: -1, r: 1}, {q: 0, r: 1}
            ];

            return directions
                .map(d => ({q: q + d.q, r: r + d.r}))
                .filter(hex => isValidHex(hex.q, hex.r))
                .map(hex => `${hex.q},${hex.r}`);
        }

        // Draw a hexagon
        function drawHex(centerX, centerY, fill = null, stroke = '#333') {
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = Math.PI / 3 * i;
                const x = centerX + HEX_SIZE * Math.cos(angle);
                const y = centerY + HEX_SIZE * Math.sin(angle);
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.closePath();

            if (fill) {
                ctx.fillStyle = fill;
                ctx.fill();
            }

            ctx.strokeStyle = stroke;
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        // Draw a ball
        function drawBall(centerX, centerY, colorIndex, isSelected = false, scale = 1, opacity = 1) {
            ctx.save();
            ctx.globalAlpha = opacity;

            const radius = HEX_SIZE * 0.7 * scale;
            const baseColor = COLORS[colorIndex % COLORS.length] || '#FFFFFF';
            const highlightColor = adjustColor(baseColor, 70);
            const shadowColor = adjustColor(baseColor, -60);

            const fillGradient = ctx.createRadialGradient(
                centerX - radius * 0.35,
                centerY - radius * 0.4,
                radius * 0.15,
                centerX,
                centerY,
                radius
            );
            fillGradient.addColorStop(0, highlightColor);
            fillGradient.addColorStop(0.55, baseColor);
            fillGradient.addColorStop(1, shadowColor);

            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.fillStyle = fillGradient;
            ctx.fill();

            const rimGradient = ctx.createLinearGradient(centerX, centerY - radius, centerX, centerY + radius);
            rimGradient.addColorStop(0, 'rgba(255,255,255,0.35)');
            rimGradient.addColorStop(0.5, 'rgba(255,255,255,0.08)');
            rimGradient.addColorStop(1, 'rgba(0,0,0,0.35)');

            ctx.strokeStyle = rimGradient;
            ctx.lineWidth = Math.max(1, HEX_SIZE * 0.06 * scale);
            ctx.stroke();

            const glintRadius = radius * 0.38;
            const glintX = centerX - radius * 0.4;
            const glintY = centerY - radius * 0.45;
            const glintGradient = ctx.createRadialGradient(glintX, glintY, 0, glintX, glintY, glintRadius);
            glintGradient.addColorStop(0, 'rgba(255,255,255,0.9)');
            glintGradient.addColorStop(1, 'rgba(255,255,255,0)');

            ctx.beginPath();
            ctx.arc(glintX, glintY, glintRadius, 0, Math.PI * 2);
            ctx.fillStyle = glintGradient;
            ctx.fill();

            if (isSelected) {
                ctx.save();
                const outlineRadius = radius + Math.max(2, HEX_SIZE * 0.1 * scale);
                ctx.lineWidth = Math.max(2, HEX_SIZE * 0.12 * scale);
                ctx.strokeStyle = 'rgba(255,255,255,0.85)';
                ctx.shadowColor = 'rgba(0,0,0,0.45)';
                ctx.shadowBlur = HEX_SIZE * 0.35;
                ctx.beginPath();
                ctx.arc(centerX, centerY, outlineRadius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }

            ctx.restore();
        }

        // Draw touch feedback
        function drawTouchFeedback(q, r) {
            const pos = hexToPixel(q, r);
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = Math.PI / 3 * i;
                const x = pos.x + HEX_SIZE * Math.cos(angle);
                const y = pos.y + HEX_SIZE * Math.sin(angle);
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.closePath();
            ctx.stroke();
            ctx.restore();
        }

        // Render the game
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (selectedCell && !grid.has(selectedCell)) {
                stopSelectedBallHop();
                selectedCell = null;
            }

            // Draw all hexes
            const allCells = getAllCells();
            for (const cellKey of allCells) {
                const [q, r] = cellKey.split(',').map(Number);
                const pos = hexToPixel(q, r);

                // Check if this is the blocked cell (show red flash)
                if (blockedCell && blockedCell.q === q && blockedCell.r === r) {
                    const alpha = 1 - blockedCell.flashProgress;
                    drawHex(pos.x, pos.y, '#999', `rgba(255, 0, 0, ${alpha})`);
                    // Draw extra thick red outline
                    ctx.save();
                    ctx.strokeStyle = `rgba(255, 0, 0, ${alpha})`;
                    ctx.lineWidth = 5;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = Math.PI / 3 * i;
                        const x = pos.x + HEX_SIZE * Math.cos(angle);
                        const y = pos.y + HEX_SIZE * Math.sin(angle);
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();
                } else {
                    drawHex(pos.x, pos.y, '#999');
                }

                if (grid.has(cellKey)) {
                    const cell = grid.get(cellKey);
                    const isSelected = selectedCell === cellKey;
                    let drawY = pos.y;
                    let drawScale = 1;
                    if (isSelected && selectedBallAnimation && selectedBallAnimation.cellKey === cellKey) {
                        drawY += selectedBallAnimation.offsetY;
                        drawScale = selectedBallAnimation.scale;
                    }
                    drawBall(pos.x, drawY, cell.color, isSelected, drawScale);

                    // If this ball is the blocked source, add red outline flash
                    if (blockedSourceCell && blockedSourceCell.q === q && blockedSourceCell.r === r) {
                        const alpha = 1 - blockedSourceCell.flashProgress;
                        ctx.save();
                        ctx.strokeStyle = `rgba(255, 0, 0, ${alpha})`;
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(pos.x, pos.y, HEX_SIZE * 0.7, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.restore();
                    }
                }

                // Draw touch feedback
                if (touchedHex && touchedHex.q === q && touchedHex.r === r) {
                    drawTouchFeedback(q, r);
                }
            }

            // Draw animated balls (on top of everything)
            for (const ball of animatedBalls) {
                const pos = hexToPixel(ball.q, ball.r);
                const offsetY = ball.offsetY || 0;
                drawBall(pos.x, pos.y + offsetY, ball.color, false, ball.scale, ball.opacity);
            }
        }

        function redrawBoard(){
            render();
        }

        // ====== ANIMATION FUNCTIONS ======

        // Animate ball movement along a path with hopping effect
        function animateMoveBallAlongPath(path, ball, onComplete) {
            if (!path || path.length < 2) {
                if (onComplete) onComplete();
                return;
            }

            inputLocked = true;

            const fromKey = path[0];
            const [fromQ, fromR] = fromKey.split(',').map(Number);

            // Create animated ball with additional properties for jumping
            const animBall = {
                q: fromQ,
                r: fromR,
                color: ball.color,
                scale: 1,
                opacity: 1,
                offsetY: 0  // Vertical offset for jumping effect
            };
            animatedBalls.push(animBall);

            // Remove ball from source in grid (it's now being animated)
            grid.delete(fromKey);

            let currentSegment = 0;

            function animateNextHop() {
                if (currentSegment >= path.length - 1) {
                    // Animation complete - place ball at final destination
                    const finalKey = path[path.length - 1];
                    animatedBalls = animatedBalls.filter(b => b !== animBall);
                    grid.set(finalKey, ball);
                    inputLocked = false;
                    if (onComplete) onComplete();
                    return;
                }

                const fromKey = path[currentSegment];
                const toKey = path[currentSegment + 1];
                const [fromQ, fromR] = fromKey.split(',').map(Number);
                const [toQ, toR] = toKey.split(',').map(Number);

                currentSegment++;

                const hopDuration = 150; // 150ms per hop

                addAnimation(
                    (progress) => {
                        const eased = easeOutQuad(progress);

                        // Move between cells
                        animBall.q = fromQ + (toQ - fromQ) * eased;
                        animBall.r = fromR + (toR - fromR) * eased;

                        // Create parabolic arc (jump effect)
                        // Peak of jump is at progress = 0.5
                        const jumpHeight = HEX_SIZE * 0.4;
                        const jumpProgress = Math.sin(progress * Math.PI);
                        animBall.offsetY = -jumpHeight * jumpProgress;

                        // Slight scale increase during jump
                        const scaleBoost = 1 + (0.15 * jumpProgress);
                        animBall.scale = scaleBoost;
                    },
                    () => {
                        // This hop is complete, start next one
                        animateNextHop();
                    },
                    hopDuration
                );
            }

            // Start the hopping animation
            animateNextHop();
        }

        // Animate blocked move (red flash on both source ball and destination cell)
        function animateBlockedMove(sourceKey, destKey) {
            const [destQ, destR] = destKey.split(',').map(Number);
            const [srcQ, srcR] = sourceKey.split(',').map(Number);
            blockedCell = { q: destQ, r: destR, flashProgress: 0 };
            blockedSourceCell = { q: srcQ, r: srcR, flashProgress: 0 };
            flashInvalid(canvas);

            addAnimation(
                (progress) => {
                    blockedCell.flashProgress = progress;
                    blockedSourceCell.flashProgress = progress;
                },
                () => {
                    blockedCell = null;
                    blockedSourceCell = null;
                },
                200 // 200ms duration
            );
        }

        // Animate spawning balls
        function animateSpawnBalls(cellsAndColors, onComplete) {
            inputLocked = true;

            // Create animated balls for each spawn
            const newAnimBalls = [];
            for (const { cellKey, color } of cellsAndColors) {
                const [q, r] = cellKey.split(',').map(Number);
                const animBall = {
                    q, r, color,
                    scale: 0,
                    opacity: 1
                };
                animatedBalls.push(animBall);
                newAnimBalls.push(animBall);
            }

            addAnimation(
                (progress) => {
                    const eased = easeOutQuad(progress);
                    for (const ball of newAnimBalls) {
                        ball.scale = eased;
                    }
                },
                () => {
                    // Animation complete - place balls in grid
                    for (const ball of newAnimBalls) {
                        const cellKey = `${Math.round(ball.q)},${Math.round(ball.r)}`;
                        grid.set(cellKey, { color: ball.color });
                    }
                    animatedBalls = animatedBalls.filter(b => !newAnimBalls.includes(b));
                    inputLocked = false;
                    if (onComplete) onComplete();
                },
                180 // 180ms duration
            );
        }

        // Animate removing balls (scale down + fade)
        function animateRemoveBalls(cellKeys, onComplete) {
            inputLocked = true;

            // Create animated balls for each cell to remove
            const removeAnimBalls = [];
            for (const cellKey of cellKeys) {
                const [q, r] = cellKey.split(',').map(Number);
                const cell = grid.get(cellKey);
                if (!cell) continue;

                if (cellKey === selectedCell) {
                    stopSelectedBallHop();
                    selectedCell = null;
                }

                const animBall = {
                    q, r,
                    color: cell.color,
                    scale: 1,
                    opacity: 1
                };
                animatedBalls.push(animBall);
                removeAnimBalls.push(animBall);

                // Remove from grid immediately so it doesn't render normally
                grid.delete(cellKey);
            }

            addAnimation(
                (progress) => {
                    const eased = easeInQuad(progress);
                    for (const ball of removeAnimBalls) {
                        ball.scale = 1 - eased;
                        ball.opacity = 1 - eased;
                    }
                },
                () => {
                    // Animation complete - remove animated balls
                    animatedBalls = animatedBalls.filter(b => !removeAnimBalls.includes(b));
                    inputLocked = false;
                    if (onComplete) onComplete();
                },
                220 // 220ms duration
            );
        }

        // ====== END ANIMATION FUNCTIONS ======

        // BFS pathfinding - returns path as array of cell keys, or null if no path exists
        function findPath(startKey, endKey) {
            if (startKey === endKey) return [startKey];
            if (grid.has(endKey)) return null;

            const queue = [startKey];
            const visited = new Set([startKey]);
            const parent = new Map(); // Track parent for path reconstruction
            parent.set(startKey, null);

            while (queue.length > 0) {
                const current = queue.shift();
                const [q, r] = current.split(',').map(Number);
                const neighbors = getNeighbors(q, r);

                for (const neighbor of neighbors) {
                    if (neighbor === endKey) {
                        // Found the path! Reconstruct it
                        const path = [endKey];
                        let step = current;
                        while (step !== null) {
                            path.unshift(step);
                            step = parent.get(step);
                        }
                        return path;
                    }

                    if (!visited.has(neighbor) && !grid.has(neighbor)) {
                        visited.add(neighbor);
                        parent.set(neighbor, current);
                        queue.push(neighbor);
                    }
                }
            }

            return null;
        }

        // Flood fill to find connected group
        function findGroup(startKey) {
            if (!grid.has(startKey)) return [];

            const startColor = grid.get(startKey).color;
            const group = [];
            const visited = new Set();
            const queue = [startKey];

            while (queue.length > 0) {
                const current = queue.shift();
                if (visited.has(current)) continue;

                visited.add(current);
                if (!grid.has(current) || grid.get(current).color !== startColor) continue;

                group.push(current);

                const [q, r] = current.split(',').map(Number);
                const neighbors = getNeighbors(q, r);
                for (const neighbor of neighbors) {
                    if (!visited.has(neighbor)) {
                        queue.push(neighbor);
                    }
                }
            }

            return group;
        }

        // Calculate score for group size
        function calculateScore(groupSize) {
            // Triangular number progression: 6=6, 7=8, 8=11, 9=15, etc.
            // Formula: n + (n-6)*(n-5)/2
            if (groupSize < 6) return 0;
            return groupSize + (groupSize - 6) * (groupSize - 5) / 2;
        }

        // Remove groups with animation and callback
        function checkAndRemoveGroups(cellsToCheck, callback) {
            let totalScore = 0;

            function checkIteration() {
                const checkedCells = new Set();
                let foundGroup = null;

                for (const cellKey of cellsToCheck) {
                    if (checkedCells.has(cellKey) || !grid.has(cellKey)) continue;

                    const group = findGroup(cellKey);
                    group.forEach(cell => checkedCells.add(cell));

                    if (group.length >= 6) {
                        foundGroup = group;
                        break; // Found a group, animate it
                    }
                }

                if (foundGroup) {
                    // Animate removal
                    const groupScore = calculateScore(foundGroup.length);
                    totalScore += groupScore;

                    animateRemoveBalls(foundGroup, () => {
                        // After animation, check for chain reactions
                        cellsToCheck = getAllCells();
                        checkIteration();
                    });
                } else {
                    // No more groups found
                    if (callback) callback(totalScore);
                }
            }

            checkIteration();
        }

        // Show game over screen
        function showGameOver() {
            gameOver = true;

            // Update high score if needed
            if (score > highScore) {
                highScore = score;
                saveHighScore();
            }
            hudSet(score, highScore, turnCount, grid.size);

            // Display scores
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalTurns').textContent = turnCount;
            document.getElementById('highScore').textContent = highScore;
            document.getElementById('gameOver').style.display = 'flex';
        }

        // Spawn new balls with animation
        function spawnBalls(callback) {
            const emptyCells = getAllEmptyCells();
            const spawnCount = getSpawnCountForState(turnCount, emptyCells.length);

            if (spawnCount <= 0) {
                preview = generatePreview();
                updatePreviewDisplay();
                render();
                if (callback) callback();
                return;
            }

            if (preview.length > spawnCount) {
                preview = preview.slice(0, spawnCount);
                updatePreviewDisplay();
            } else if (preview.length < spawnCount) {
                const needed = spawnCount - preview.length;
                for (let i = 0; i < needed; i++) {
                    preview.push(Math.floor(Math.random() * availableColorCount));
                }
                updatePreviewDisplay();
            }

            const ballsToSpawn = preview.length;

            if (emptyCells.length < ballsToSpawn) {
                // Game over - not enough space
                showGameOver();
                return;
            }

            const cellsAndColors = [];

            // Prepare spawn data
            for (let i = 0; i < ballsToSpawn; i++) {
                if (emptyCells.length === 0) break;

                const idx = Math.floor(Math.random() * emptyCells.length);
                const cellKey = emptyCells.splice(idx, 1)[0];
                cellsAndColors.push({ cellKey, color: preview[i] });
            }

            // Animate spawning
            animateSpawnBalls(cellsAndColors, () => {
                // After spawn animation, check for groups
                const spawnedCells = cellsAndColors.map(item => item.cellKey);

                checkAndRemoveGroups(spawnedCells, (scoreGained) => {
                    if (scoreGained > 0) {
                        score += scoreGained;
                        updateScore();
                    }

                    // Generate new preview
                    preview = generatePreview();
                    updatePreviewDisplay();

                    // Check if board is full
                    if (getAllEmptyCells().length === 0) {
                        showGameOver();
                    }

                    render();
                    if (callback) callback();
                });
            });
        }

        // Handle input (used by both touch and click)
        function handleInput(x, y) {
            if (gameOver || inputLocked) return;

            const hex = pixelToHex(x, y);
            if (!isValidHex(hex.q, hex.r)) return;

            const cellKey = `${hex.q},${hex.r}`;

            // Show touch feedback
            touchedHex = { q: hex.q, r: hex.r };
            render();
            setTimeout(() => {
                touchedHex = null;
                render();
            }, 100);

            // If clicking on a ball
            if (grid.has(cellKey)) {
                selectedCell = cellKey;
                startSelectedBallHop(cellKey);
                render();
                return;
            }

            // If clicking empty cell with a ball selected
            if (selectedCell && !grid.has(cellKey)) {
                // Check if path exists and get the path
                const path = findPath(selectedCell, cellKey);
                if (path) {
                    const ball = grid.get(selectedCell);
                    stopSelectedBallHop();
                    selectedCell = null;

                    // Animate ball movement along the path
                    animateMoveBallAlongPath(path, ball, () => {
                        // Increment turn counter
                        turnCount++;
                        updateTurnDisplay();
                        updateAvailableColors();

                        // Check for groups at destination
                        checkAndRemoveGroups([cellKey], (scoreGained) => {
                            if (scoreGained > 0) {
                                // Group formed - add score, don't spawn
                                score += scoreGained;
                                updateScore();
                                preview = generatePreview();
                                updatePreviewDisplay();
                                render();
                            } else {
                                // No group - spawn new balls
                                spawnBalls();
                            }
                        });
                    });
                } else {
                    // Path blocked - show feedback
                    animateBlockedMove(selectedCell, cellKey);
                }
            }
        }

        // Get touch coordinates (accounting for canvas scaling)
        function getTouchCoords(touch) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (touch.clientX - rect.left) * scaleX,
                y: (touch.clientY - rect.top) * scaleY
            };
        }

        // Handle touch start
        function handleTouchStart(e) {
            e.preventDefault(); // Prevent ghost clicks and scrolling
            const touch = e.touches[0];
            const coords = getTouchCoords(touch);
            handleInput(coords.x, coords.y);
        }

        // Handle touch end
        function handleTouchEnd(e) {
            e.preventDefault();
        }

        // Handle click
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            handleInput(x, y);
        });

        // Touch event listeners
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd, { passive: false });

        // Handle window resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                calculateCanvasSize();
                render();
            }, 250);
        });

        // Handle reset button
        document.getElementById('resetButton').addEventListener('click', () => {
            restartGame();
        });

        // Start game
        init();
    </script>
</body>
</html>
