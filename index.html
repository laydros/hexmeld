<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hexmeld - Hexagonal Puzzle Game</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        header {
            width: 100%;
            background-color: #333;
            color: white;
            padding: 20px 0;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        header h1 {
            margin: 0;
            font-size: 32px;
            font-weight: bold;
        }

        main {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            width: 100%;
        }

        footer {
            width: 100%;
            background-color: #333;
            color: white;
            padding: 15px 0;
            text-align: center;
            font-size: 14px;
        }

        footer a {
            color: #4CAF50;
            text-decoration: none;
            margin: 0 10px;
        }

        footer a:hover {
            text-decoration: underline;
        }

        .version {
            font-size: 11px;
            color: #999;
            margin-top: 5px;
        }

        #gameContainer {
            background-color: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 100%;
            width: 100%;
        }

        #scoreBoard {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 15px;
            font-size: 16px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .leftStats, .rightStats {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .rightStats {
            align-items: flex-end;
        }

        #score, #turns, #highScoreDisplay {
            font-weight: bold;
            font-size: 20px;
            color: #333;
        }

        .stat {
            font-size: 16px;
        }

        #preview {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .previewBall {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            border: 2px solid #333;
        }

        #canvas {
            border: 2px solid #333;
            display: block;
            cursor: pointer;
            max-width: 100%;
            height: auto;
            margin: 0 auto;
        }

        @media (max-width: 768px) {
            #canvas {
                width: 100%;
            }

            #gameContainer {
                padding-left: 0;
                padding-right: 0;
            }
        }

        #gameOver {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 30px 20px;
            border-radius: 10px;
            font-size: 28px;
            font-weight: bold;
            display: none;
            text-align: center;
            max-width: 90%;
        }

        #gameOver p {
            margin: 10px 0;
            font-size: 16px;
        }

        #resetButton {
            margin-top: 20px;
            padding: 10px 30px;
            font-size: 18px;
            font-weight: bold;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #resetButton:hover {
            background-color: #45a049;
        }

        @media (max-width: 600px) {
            header h1 {
                font-size: 24px;
            }

            header {
                padding: 15px 0;
            }

            main {
                padding: 5px;
            }

            #gameContainer {
                padding: 10px;
            }

            #scoreBoard {
                font-size: 14px;
            }

            #score {
                font-size: 18px;
            }

            .previewBall {
                width: 20px;
                height: 20px;
            }

            #gameOver {
                font-size: 24px;
                padding: 20px 15px;
            }

            #gameOver p {
                font-size: 14px;
            }

            footer {
                font-size: 12px;
                padding: 10px 0;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Hexmeld</h1>
    </header>

    <main>
    <div id="gameContainer">
        <div id="scoreBoard">
            <div class="leftStats">
                <div class="stat">Score: <span id="score">0</span></div>
                <div class="stat">High: <span id="highScoreDisplay">0</span></div>
            </div>
            <div class="rightStats">
                <div id="preview">
                    <span>Next:</span>
                </div>
                <div class="stat">Turn: <span id="turns">0</span></div>
            </div>
        </div>
        <canvas id="canvas"></canvas>
    </div>
    <div id="gameOver">
        GAME OVER
        <p>Your Score: <span id="finalScore">0</span> (Turn <span id="finalTurns">0</span>)</p>
        <p>High Score: <span id="highScore">0</span></p>
        <button id="resetButton">Play Again</button>
    </div>
    </main>

    <footer>
        <div>
            <a href="instructions.html">How to Play</a> |
            <a href="https://github.com/laydros/hexmeld" target="_blank">View on GitHub</a>
        </div>
        <div class="version" id="versionDisplay"></div>
    </footer>

    <script>
        // Version check
        const GAME_VERSION = '1.0.6-mobile';
        console.log('Hexmeld version:', GAME_VERSION);
        document.getElementById('versionDisplay').textContent = `v${GAME_VERSION}`;

        // Constants
        const BOARD_RADIUS = 6;
        const COLORS = [
            '#0000FF', // Blue
            '#FFFF00', // Yellow
            '#FF0000', // Red
            '#00FF00', // Green
            '#FFA500', // Orange
            '#800080', // Purple
            '#FFFFFF', // White
            '#00FFFF'  // Turquoise
        ];

        // ====== GAME CONFIG (EDIT HERE FOR TESTING) ======
        const COLOR_CONFIG = {
            startingColors: 6,  // Start with first 6 colors (0-5)
            expansions: [
                { afterTurn: 20, addColors: 2 }  // After turn 20, add 2 more colors (indices 6-7)
                // Add more expansions like: { afterTurn: 50, addColors: 2 }
            ]
        };

        const SPAWN_CONFIG = {
            startingSpawnCount: 3,  // Start spawning 3 balls per turn
            increases: [
                { afterTurn: 40, spawnCount: 4 }  // After turn 40, spawn 4 balls per turn
                // Add more increases like: { afterTurn: 80, spawnCount: 5 }
            ]
        };
        // ==================================================

        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Game state
        let grid = new Map();
        let selectedCell = null;
        let score = 0;
        let turnCount = 0;
        let availableColorCount = COLOR_CONFIG.startingColors;
        let preview = [];
        let gameOver = false;
        let highScore = 0;
        let inputLocked = false; // Prevent input during animations

        // Animation state
        const animations = [];
        let animationFrameId = null;

        // Dynamic sizing
        let HEX_SIZE = 25;
        let hexWidth = HEX_SIZE * 2;
        let hexHeight = Math.sqrt(3) * HEX_SIZE;
        let isMobile = false;
        let hitRadius = HEX_SIZE * 0.5;

        // Calculate optimal canvas size and hex size
        function calculateCanvasSize() {
            // Detect mobile
            isMobile = window.innerWidth < 768;

            // Minimal canvas padding
            const canvasPadding = isMobile ? 20 : 40;

            // Available space for the entire canvas
            const availableWidth = window.innerWidth - canvasPadding;
            const availableHeight = window.innerHeight - 200;

            // Board dimensions: how much space the hex board actually needs
            // Horizontal: furthest hex at q=±BOARD_RADIUS is at ±(1.5 * BOARD_RADIUS * HEX_SIZE)
            // Plus one hex radius on each side = total of (3 * BOARD_RADIUS + 2) * HEX_SIZE
            const boardHexWidth = 3 * BOARD_RADIUS + 2;

            // Vertical: approximately (sqrt(3) * (BOARD_RADIUS * 2 + 1)) * HEX_SIZE
            const boardHexHeight = Math.sqrt(3) * (BOARD_RADIUS * 2 + 1);

            // Calculate max hex size that fits with tight padding around board
            const boardPadding = isMobile ? 10 : 20; // Padding around the board within canvas
            const maxHexWidth = (availableWidth - boardPadding * 2) / boardHexWidth;
            const maxHexHeight = (availableHeight - boardPadding * 2) / boardHexHeight;

            HEX_SIZE = Math.min(maxHexWidth, maxHexHeight, 25);
            // Ensure minimum size of 20px for mobile touch targets
            HEX_SIZE = Math.max(HEX_SIZE, isMobile ? 20 : 10);

            hexWidth = HEX_SIZE * 2;
            hexHeight = Math.sqrt(3) * HEX_SIZE;

            // Update hit radius based on device type
            hitRadius = isMobile ? HEX_SIZE * 0.6 : HEX_SIZE * 0.5;

            // Calculate tight canvas dimensions: just enough for board + padding
            const canvasWidth = boardHexWidth * HEX_SIZE + boardPadding * 2;
            const canvasHeight = boardHexHeight * HEX_SIZE + boardPadding * 2;

            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
        }

        // ====== ANIMATION FRAMEWORK ======

        // Easing functions
        function easeOutQuad(t) {
            return 1 - Math.pow(1 - t, 2);
        }

        function easeInQuad(t) {
            return t * t;
        }

        // Animation loop
        function animationLoop() {
            if (animations.length === 0) {
                animationFrameId = null;
                return;
            }

            const now = performance.now();

            // Update all animations
            for (let i = animations.length - 1; i >= 0; i--) {
                const anim = animations[i];
                const elapsed = now - anim.startTime;
                const progress = Math.min(1, elapsed / anim.duration);

                anim.update(progress);

                if (progress >= 1) {
                    if (anim.onComplete) {
                        anim.onComplete();
                    }
                    animations.splice(i, 1);
                }
            }

            render();

            if (animations.length > 0) {
                animationFrameId = requestAnimationFrame(animationLoop);
            } else {
                animationFrameId = null;
            }
        }

        // Add an animation
        function addAnimation(update, onComplete, duration) {
            animations.push({
                startTime: performance.now(),
                duration,
                update,
                onComplete
            });

            if (!animationFrameId) {
                animationFrameId = requestAnimationFrame(animationLoop);
            }
        }

        // Wait for all animations to complete
        function waitForAnimations(callback) {
            if (animations.length === 0) {
                callback();
            } else {
                const checkInterval = setInterval(() => {
                    if (animations.length === 0) {
                        clearInterval(checkInterval);
                        callback();
                    }
                }, 10);
            }
        }

        // ====== END ANIMATION FRAMEWORK ======

        // Animation overlays (drawn on top of normal rendering)
        let animatedBalls = []; // { q, r, color, scale, opacity }
        let blockedCell = null; // { q, r, flashProgress }
        let blockedSourceCell = null; // { q, r, flashProgress }
        let touchedHex = null; // For touch feedback

        // ====== END ANIMATION FRAMEWORK ======

        // Load high score from localStorage
        function loadHighScore() {
            const saved = localStorage.getItem('hexmeldHighScore');
            highScore = saved ? parseInt(saved, 10) : 0;
        }

        // Save high score to localStorage
        function saveHighScore() {
            localStorage.setItem('hexmeldHighScore', highScore.toString());
        }

        // Initialize game
        function init() {
            calculateCanvasSize();
            grid.clear();
            selectedCell = null;
            score = 0;
            turnCount = 0;
            availableColorCount = COLOR_CONFIG.startingColors;
            gameOver = false;
            document.getElementById('gameOver').style.display = 'none';

            // Load high score
            loadHighScore();
            document.getElementById('highScoreDisplay').textContent = highScore;

            // Generate initial preview
            preview = generatePreview();
            updatePreviewDisplay();

            // Place 5-7 random starting balls
            const startBalls = 5 + Math.floor(Math.random() * 3);
            const emptyCells = getAllEmptyCells();
            for (let i = 0; i < startBalls; i++) {
                if (emptyCells.length > 0) {
                    const idx = Math.floor(Math.random() * emptyCells.length);
                    const cell = emptyCells.splice(idx, 1)[0];
                    const color = Math.floor(Math.random() * availableColorCount);
                    grid.set(cell, { color });
                }
            }

            updateScore();
            updateTurnDisplay();
            render();
        }

        // Update available colors based on turn count
        function updateAvailableColors() {
            let newColorCount = COLOR_CONFIG.startingColors;
            for (const expansion of COLOR_CONFIG.expansions) {
                if (turnCount >= expansion.afterTurn) {
                    newColorCount += expansion.addColors;
                }
            }
            availableColorCount = Math.min(newColorCount, COLORS.length);
        }

        // Get spawn count for a specific turn
        function getSpawnCountForTurn(turn) {
            let spawnCount = SPAWN_CONFIG.startingSpawnCount;
            for (const increase of SPAWN_CONFIG.increases) {
                if (turn >= increase.afterTurn) {
                    spawnCount = increase.spawnCount;
                }
            }
            return spawnCount;
        }

        // Generate preview of random balls (looks ahead to next turn's spawn count)
        function generatePreview() {
            const nextTurnSpawnCount = getSpawnCountForTurn(turnCount + 1);
            const previewArray = [];
            for (let i = 0; i < nextTurnSpawnCount; i++) {
                previewArray.push(Math.floor(Math.random() * availableColorCount));
            }
            return previewArray;
        }

        // Update preview display
        function updatePreviewDisplay() {
            const previewContainer = document.getElementById('preview');
            // Clear existing preview balls (except the "Next:" label)
            const existingBalls = previewContainer.querySelectorAll('.previewBall');
            existingBalls.forEach(ball => ball.remove());

            // Add new preview balls
            for (let i = 0; i < preview.length; i++) {
                const ball = document.createElement('div');
                ball.className = 'previewBall';
                ball.style.backgroundColor = COLORS[preview[i]];
                previewContainer.appendChild(ball);
            }
        }

        // Update score display
        function updateScore() {
            document.getElementById('score').textContent = score;
        }

        // Update turn display
        function updateTurnDisplay() {
            document.getElementById('turns').textContent = turnCount;
        }

        // Get all valid hex cells for the board
        function getAllCells() {
            const cells = [];
            for (let q = -BOARD_RADIUS; q <= BOARD_RADIUS; q++) {
                for (let r = -BOARD_RADIUS; r <= BOARD_RADIUS; r++) {
                    const s = -q - r;
                    if (Math.abs(s) <= BOARD_RADIUS) {
                        cells.push(`${q},${r}`);
                    }
                }
            }
            return cells;
        }

        // Get all empty cells
        function getAllEmptyCells() {
            return getAllCells().filter(cell => !grid.has(cell));
        }

        // Convert offset coordinates to cube coordinates
        function offsetToCube(col, row) {
            const q = col;
            const r = row - (col - (col & 1)) / 2;
            return { q, r, s: -q - r };
        }

        // Convert cube coordinates to offset coordinates
        function cubeToOffset(q, r) {
            const col = q;
            const row = r + (q - (q & 1)) / 2;
            return { col, row };
        }

        // Get hex center position in pixels
        function hexToPixel(q, r) {
            const x = HEX_SIZE * (3/2 * q);
            const y = HEX_SIZE * (Math.sqrt(3)/2 * q + Math.sqrt(3) * r);
            return {
                x: x + canvas.width / 2,
                y: y + canvas.height / 2
            };
        }

        // Convert pixel to hex coordinates
        function pixelToHex(x, y) {
            x -= canvas.width / 2;
            y -= canvas.height / 2;

            const q = (2/3 * x) / HEX_SIZE;
            const r = (-1/3 * x + Math.sqrt(3)/3 * y) / HEX_SIZE;
            return hexRound(q, r);
        }

        // Round fractional hex coordinates to nearest hex
        function hexRound(q, r) {
            let s = -q - r;

            let rq = Math.round(q);
            let rr = Math.round(r);
            let rs = Math.round(s);

            const q_diff = Math.abs(rq - q);
            const r_diff = Math.abs(rr - r);
            const s_diff = Math.abs(rs - s);

            if (q_diff > r_diff && q_diff > s_diff) {
                rq = -rr - rs;
            } else if (r_diff > s_diff) {
                rr = -rq - rs;
            }

            return { q: rq, r: rr };
        }

        // Check if hex is valid (within board)
        function isValidHex(q, r) {
            const s = -q - r;
            return Math.abs(q) <= BOARD_RADIUS &&
                   Math.abs(r) <= BOARD_RADIUS &&
                   Math.abs(s) <= BOARD_RADIUS;
        }

        // Get neighbors of a hex
        function getNeighbors(q, r) {
            const directions = [
                {q: 1, r: 0}, {q: 1, r: -1}, {q: 0, r: -1},
                {q: -1, r: 0}, {q: -1, r: 1}, {q: 0, r: 1}
            ];

            return directions
                .map(d => ({q: q + d.q, r: r + d.r}))
                .filter(hex => isValidHex(hex.q, hex.r))
                .map(hex => `${hex.q},${hex.r}`);
        }

        // Draw a hexagon
        function drawHex(centerX, centerY, fill = null, stroke = '#333') {
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = Math.PI / 3 * i;
                const x = centerX + HEX_SIZE * Math.cos(angle);
                const y = centerY + HEX_SIZE * Math.sin(angle);
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.closePath();

            if (fill) {
                ctx.fillStyle = fill;
                ctx.fill();
            }

            ctx.strokeStyle = stroke;
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        // Draw a ball
        function drawBall(centerX, centerY, colorIndex, isSelected = false, scale = 1, opacity = 1) {
            ctx.save();
            ctx.globalAlpha = opacity;

            ctx.beginPath();
            ctx.arc(centerX, centerY, HEX_SIZE * 0.7 * scale, 0, Math.PI * 2);
            ctx.fillStyle = COLORS[colorIndex];
            ctx.fill();

            if (isSelected) {
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.stroke();
            }

            ctx.restore();
        }

        // Draw touch feedback
        function drawTouchFeedback(q, r) {
            const pos = hexToPixel(q, r);
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = Math.PI / 3 * i;
                const x = pos.x + HEX_SIZE * Math.cos(angle);
                const y = pos.y + HEX_SIZE * Math.sin(angle);
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.closePath();
            ctx.stroke();
            ctx.restore();
        }

        // Render the game
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw all hexes
            const allCells = getAllCells();
            for (const cellKey of allCells) {
                const [q, r] = cellKey.split(',').map(Number);
                const pos = hexToPixel(q, r);

                // Check if this is the blocked cell (show red flash)
                if (blockedCell && blockedCell.q === q && blockedCell.r === r) {
                    const alpha = 1 - blockedCell.flashProgress;
                    drawHex(pos.x, pos.y, '#999', `rgba(255, 0, 0, ${alpha})`);
                    // Draw extra thick red outline
                    ctx.save();
                    ctx.strokeStyle = `rgba(255, 0, 0, ${alpha})`;
                    ctx.lineWidth = 5;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = Math.PI / 3 * i;
                        const x = pos.x + HEX_SIZE * Math.cos(angle);
                        const y = pos.y + HEX_SIZE * Math.sin(angle);
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();
                } else {
                    drawHex(pos.x, pos.y, '#999');
                }

                if (grid.has(cellKey)) {
                    const cell = grid.get(cellKey);
                    const isSelected = selectedCell === cellKey;
                    drawBall(pos.x, pos.y, cell.color, isSelected);

                    // If this ball is the blocked source, add red outline flash
                    if (blockedSourceCell && blockedSourceCell.q === q && blockedSourceCell.r === r) {
                        const alpha = 1 - blockedSourceCell.flashProgress;
                        ctx.save();
                        ctx.strokeStyle = `rgba(255, 0, 0, ${alpha})`;
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(pos.x, pos.y, HEX_SIZE * 0.7, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.restore();
                    }
                }

                // Draw touch feedback
                if (touchedHex && touchedHex.q === q && touchedHex.r === r) {
                    drawTouchFeedback(q, r);
                }
            }

            // Draw animated balls (on top of everything)
            for (const ball of animatedBalls) {
                const pos = hexToPixel(ball.q, ball.r);
                drawBall(pos.x, pos.y, ball.color, false, ball.scale, ball.opacity);
            }
        }

        // ====== ANIMATION FUNCTIONS ======

        // Animate ball movement from source to destination
        function animateMoveBall(fromKey, toKey, ball, onComplete) {
            inputLocked = true;

            const [fromQ, fromR] = fromKey.split(',').map(Number);
            const [toQ, toR] = toKey.split(',').map(Number);
            const fromPos = hexToPixel(fromQ, fromR);
            const toPos = hexToPixel(toQ, toR);

            // Create animated ball
            const animBall = {
                q: fromQ,
                r: fromR,
                color: ball.color,
                scale: 1,
                opacity: 1
            };
            animatedBalls.push(animBall);

            // Remove ball from source in grid (it's now being animated)
            grid.delete(fromKey);

            addAnimation(
                (progress) => {
                    const eased = easeOutQuad(progress);
                    animBall.q = fromQ + (toQ - fromQ) * eased;
                    animBall.r = fromR + (toR - fromR) * eased;
                },
                () => {
                    // Animation complete - place ball at destination
                    animatedBalls = animatedBalls.filter(b => b !== animBall);
                    grid.set(toKey, ball);
                    inputLocked = false;
                    if (onComplete) onComplete();
                },
                250 // 250ms duration
            );
        }

        // Animate blocked move (red flash on both source ball and destination cell)
        function animateBlockedMove(sourceKey, destKey) {
            const [destQ, destR] = destKey.split(',').map(Number);
            const [srcQ, srcR] = sourceKey.split(',').map(Number);
            blockedCell = { q: destQ, r: destR, flashProgress: 0 };
            blockedSourceCell = { q: srcQ, r: srcR, flashProgress: 0 };

            addAnimation(
                (progress) => {
                    blockedCell.flashProgress = progress;
                    blockedSourceCell.flashProgress = progress;
                },
                () => {
                    blockedCell = null;
                    blockedSourceCell = null;
                },
                200 // 200ms duration
            );
        }

        // Animate spawning balls
        function animateSpawnBalls(cellsAndColors, onComplete) {
            inputLocked = true;

            // Create animated balls for each spawn
            const newAnimBalls = [];
            for (const { cellKey, color } of cellsAndColors) {
                const [q, r] = cellKey.split(',').map(Number);
                const animBall = {
                    q, r, color,
                    scale: 0,
                    opacity: 1
                };
                animatedBalls.push(animBall);
                newAnimBalls.push(animBall);
            }

            addAnimation(
                (progress) => {
                    const eased = easeOutQuad(progress);
                    for (const ball of newAnimBalls) {
                        ball.scale = eased;
                    }
                },
                () => {
                    // Animation complete - place balls in grid
                    for (const ball of newAnimBalls) {
                        const cellKey = `${Math.round(ball.q)},${Math.round(ball.r)}`;
                        grid.set(cellKey, { color: ball.color });
                    }
                    animatedBalls = animatedBalls.filter(b => !newAnimBalls.includes(b));
                    inputLocked = false;
                    if (onComplete) onComplete();
                },
                180 // 180ms duration
            );
        }

        // Animate removing balls (scale down + fade)
        function animateRemoveBalls(cellKeys, onComplete) {
            inputLocked = true;

            // Create animated balls for each cell to remove
            const removeAnimBalls = [];
            for (const cellKey of cellKeys) {
                const [q, r] = cellKey.split(',').map(Number);
                const cell = grid.get(cellKey);
                if (!cell) continue;

                const animBall = {
                    q, r,
                    color: cell.color,
                    scale: 1,
                    opacity: 1
                };
                animatedBalls.push(animBall);
                removeAnimBalls.push(animBall);

                // Remove from grid immediately so it doesn't render normally
                grid.delete(cellKey);
            }

            addAnimation(
                (progress) => {
                    const eased = easeInQuad(progress);
                    for (const ball of removeAnimBalls) {
                        ball.scale = 1 - eased;
                        ball.opacity = 1 - eased;
                    }
                },
                () => {
                    // Animation complete - remove animated balls
                    animatedBalls = animatedBalls.filter(b => !removeAnimBalls.includes(b));
                    inputLocked = false;
                    if (onComplete) onComplete();
                },
                220 // 220ms duration
            );
        }

        // ====== END ANIMATION FUNCTIONS ======

        // BFS pathfinding
        function findPath(startKey, endKey) {
            if (startKey === endKey) return true;
            if (grid.has(endKey)) return false;

            const queue = [startKey];
            const visited = new Set([startKey]);

            while (queue.length > 0) {
                const current = queue.shift();
                const [q, r] = current.split(',').map(Number);
                const neighbors = getNeighbors(q, r);

                for (const neighbor of neighbors) {
                    if (neighbor === endKey) return true;

                    if (!visited.has(neighbor) && !grid.has(neighbor)) {
                        visited.add(neighbor);
                        queue.push(neighbor);
                    }
                }
            }

            return false;
        }

        // Flood fill to find connected group
        function findGroup(startKey) {
            if (!grid.has(startKey)) return [];

            const startColor = grid.get(startKey).color;
            const group = [];
            const visited = new Set();
            const queue = [startKey];

            while (queue.length > 0) {
                const current = queue.shift();
                if (visited.has(current)) continue;

                visited.add(current);
                if (!grid.has(current) || grid.get(current).color !== startColor) continue;

                group.push(current);

                const [q, r] = current.split(',').map(Number);
                const neighbors = getNeighbors(q, r);
                for (const neighbor of neighbors) {
                    if (!visited.has(neighbor)) {
                        queue.push(neighbor);
                    }
                }
            }

            return group;
        }

        // Calculate score for group size
        function calculateScore(groupSize) {
            // Triangular number progression: 6=6, 7=8, 8=11, 9=15, etc.
            // Formula: n + (n-6)*(n-5)/2
            if (groupSize < 6) return 0;
            return groupSize + (groupSize - 6) * (groupSize - 5) / 2;
        }

        // Remove groups with animation and callback
        function checkAndRemoveGroups(cellsToCheck, callback) {
            let totalScore = 0;

            function checkIteration() {
                const checkedCells = new Set();
                let foundGroup = null;

                for (const cellKey of cellsToCheck) {
                    if (checkedCells.has(cellKey) || !grid.has(cellKey)) continue;

                    const group = findGroup(cellKey);
                    group.forEach(cell => checkedCells.add(cell));

                    if (group.length >= 6) {
                        foundGroup = group;
                        break; // Found a group, animate it
                    }
                }

                if (foundGroup) {
                    // Animate removal
                    const groupScore = calculateScore(foundGroup.length);
                    totalScore += groupScore;

                    animateRemoveBalls(foundGroup, () => {
                        // After animation, check for chain reactions
                        cellsToCheck = getAllCells();
                        checkIteration();
                    });
                } else {
                    // No more groups found
                    if (callback) callback(totalScore);
                }
            }

            checkIteration();
        }

        // Show game over screen
        function showGameOver() {
            gameOver = true;

            // Update high score if needed
            if (score > highScore) {
                highScore = score;
                saveHighScore();
                document.getElementById('highScoreDisplay').textContent = highScore;
            }

            // Display scores
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalTurns').textContent = turnCount;
            document.getElementById('highScore').textContent = highScore;
            document.getElementById('gameOver').style.display = 'block';
        }

        // Spawn new balls with animation
        function spawnBalls(callback) {
            const emptyCells = getAllEmptyCells();
            const ballsToSpawn = preview.length;

            if (emptyCells.length < ballsToSpawn) {
                // Game over - not enough space
                showGameOver();
                return;
            }

            const cellsAndColors = [];

            // Prepare spawn data
            for (let i = 0; i < ballsToSpawn; i++) {
                if (emptyCells.length === 0) break;

                const idx = Math.floor(Math.random() * emptyCells.length);
                const cellKey = emptyCells.splice(idx, 1)[0];
                cellsAndColors.push({ cellKey, color: preview[i] });
            }

            // Animate spawning
            animateSpawnBalls(cellsAndColors, () => {
                // After spawn animation, check for groups
                const spawnedCells = cellsAndColors.map(item => item.cellKey);

                checkAndRemoveGroups(spawnedCells, (scoreGained) => {
                    if (scoreGained > 0) {
                        score += scoreGained;
                        updateScore();
                    }

                    // Generate new preview
                    preview = generatePreview();
                    updatePreviewDisplay();

                    // Check if board is full
                    if (getAllEmptyCells().length === 0) {
                        showGameOver();
                    }

                    render();
                    if (callback) callback();
                });
            });
        }

        // Handle input (used by both touch and click)
        function handleInput(x, y) {
            if (gameOver || inputLocked) return;

            const hex = pixelToHex(x, y);
            if (!isValidHex(hex.q, hex.r)) return;

            const cellKey = `${hex.q},${hex.r}`;

            // Show touch feedback
            touchedHex = { q: hex.q, r: hex.r };
            render();
            setTimeout(() => {
                touchedHex = null;
                render();
            }, 100);

            // If clicking on a ball
            if (grid.has(cellKey)) {
                selectedCell = cellKey;
                render();
                return;
            }

            // If clicking empty cell with a ball selected
            if (selectedCell && !grid.has(cellKey)) {
                // Check if path exists
                if (findPath(selectedCell, cellKey)) {
                    const ball = grid.get(selectedCell);
                    const moveFrom = selectedCell;
                    selectedCell = null;

                    // Animate ball movement
                    animateMoveBall(moveFrom, cellKey, ball, () => {
                        // Increment turn counter
                        turnCount++;
                        updateTurnDisplay();
                        updateAvailableColors();

                        // Check for groups at destination
                        checkAndRemoveGroups([cellKey], (scoreGained) => {
                            if (scoreGained > 0) {
                                // Group formed - add score, don't spawn
                                score += scoreGained;
                                updateScore();
                                render();
                            } else {
                                // No group - spawn new balls
                                spawnBalls();
                            }
                        });
                    });
                } else {
                    // Path blocked - show feedback
                    animateBlockedMove(selectedCell, cellKey);
                }
            }
        }

        // Get touch coordinates (accounting for canvas scaling)
        function getTouchCoords(touch) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (touch.clientX - rect.left) * scaleX,
                y: (touch.clientY - rect.top) * scaleY
            };
        }

        // Handle touch start
        function handleTouchStart(e) {
            e.preventDefault(); // Prevent ghost clicks and scrolling
            const touch = e.touches[0];
            const coords = getTouchCoords(touch);
            handleInput(coords.x, coords.y);
        }

        // Handle touch end
        function handleTouchEnd(e) {
            e.preventDefault();
        }

        // Handle click
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            handleInput(x, y);
        });

        // Touch event listeners
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd, { passive: false });

        // Handle window resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                calculateCanvasSize();
                render();
            }, 250);
        });

        // Handle reset button
        document.getElementById('resetButton').addEventListener('click', () => {
            init();
        });

        // Start game
        init();
    </script>
</body>
</html>